单例模式：被单例打对象只能有一个实例存在。
实现方式：一个类能返回对象的一个引用（永远是同一个）和一个获得该唯一实例的方法（必须为静态方法）

1.饿汉模式
	最常见、最简单的单例模式写法之一。顾名思义，“饿汉模式” 就是很 “饥渴”，所以一上来就需要给它新建
一个实例。但这种方法有一个明显的缺点，那就是不管有没有调用过获得实例的方法（本例中为 getWife() ），
每次都会新建一个实例。

2.懒汉模式
	最常见、最简单的单例模式之二，跟 “饿汉模式” 是 “好基友”。再次顾名思义，“懒汉模式” 就是它很懒，
一开始不新建实例，只有当它需要使用的时候，会先判断实例是否为空，如果为空才会新建一个实例来使用。

3.线程安全的懒汉模式
	上面的懒汉模式却存在一个严重的问题。那就是如果有多个线程并行调用 getWife() 方法的时候，还是会
创建多个实例，单例模式就失效了。我们在基本的懒汉模式上，把它设为线程同步（synchronized）就好了。
synchronized 的作用就是保证在同一时刻最多只有一个线程运行，这样就避免了多线程带来的问题。

4.双重检验锁（double check）
	线程安全的懒汉模式解决了多线程的问题，看起来完美了。但是它的效率不高，每次调用获得实例的方法 
getWife() 时都要进行同步，但是多数情况下并不需要同步操作（例如我的 wife 实例并不为空可以直接使用
的时候，就不需要给 getWife() 加同步方法，直接返回 wife 实例就可以了）。所以只需要在第一次新建实
例对象的时候，使用同步方法。于是，在前面的基础上，又有了 “双重检验锁” 的方法。
问题在于 wife = new Wife() 这句代码，因为在 JVM（Java 虚拟机）执行这句代码的时候，要做好几件事
情，而 JVM 为了优化代码，有可能造成做这几件事情的执行顺序是不固定的，从而造成错误。
这个时候，我们需要给实例加一个 volatile 关键字，它的作用就是防止编译器自行优化代码。

5.静态内部类
	上面的方法，修修补补，实在是太复杂了... 而且 volatile 关键字在某些老版本的 JDK 中无法正常工作。
咱们得换一种方法，即 “静态内部类”。这种方式，利用了 JVM 自身的机制来保证线程安全，因为 WifeHolder 
类是私有的，除了 getWife() 之外没有其它方式可以访问实例对象，而且只有在调用 getWife() 时才会去真正
创建实例对象。（这里类似于 “懒汉模式”）

6.枚举
	代码简直是简单得不能再简单了。我们可以通过 Wife.INSTANCE 来访问实例对象，这比 getWife() 要简
单得多，而且创建枚举默认就是线程安全的，还可以防止反序列化带来的问题。这么 优（niu）雅（bi）的方法，
来自于新版 《Effective Java》 这本书。这种方式虽然不常用，但是最为推荐。

